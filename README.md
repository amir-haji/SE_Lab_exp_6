# آزمایشگاه مهندسی نرم‌افزار - گزارش آزمایش ششم
[لینک مستندات آزمایش ششم](https://github.com/ssc-public/Software-Engineering-Lab/blob/main/courseworks/experiments/patterns-and-refactoring.md)

## اعضای گروه:
امیرحسین حاجی محمد رضایی - 99109252

علی رازقندی - 99109296

سید‌رضا قمقام - 99170542

## گزارش فاز اول
در این بخش در ابتدا در مورد نحوه پیاده‌سازی دو الگو state و startegy برای پیاده کردن برنامه موردنظر اشاره کرده و بعد از آن مستند دستورات برنامه اصلی را توضیح می‌دهم. این سیستم با استفاده از روش TDD ایجاد شده است و تست‌های آن را در بخش tests می‌توانید مشاهده کنید.

### نحوه اعمال کردن الگو‌ها
#### الگو state
همانطور که می‌دانیم، گراف شهری در این مساله میتواند دارای دو حالت باشد، اینکه یا همه یال‌های آن دو جهته باشند و یا اینکه یک‌طرفه باشند. در اینجا این ویژگی‌ها را به‌عنوان استیت گراف شهری در نظر می‌گیرم و این ویژگی را با الگو state به‌صورت زیر پیاده می‌کنم:

```java
// RouteState.java
package graph;

public interface RouteState {
    void changeDirection(Graph graph, boolean directed);

    void changeTimeUnit(Graph graph, int unit);
}
```

در ابتدا یک اینترفیس برای استیت ایجاد می‌کنم که متود‌های مشترک و لازم برای هردو حالت را تعریف کند.
```java
// UnidirectionalState.java
package graph;

public class UnidirectionalState implements RouteState {
    @Override
    public void changeDirection(Graph graph, boolean directed) {
        for (Node node : graph.getGraph()) {
            for (Edge edge : node.getEdges()) {
                edge.setDirected(true);
            }
        }
    }

    @Override
    public void changeTimeUnit(Graph graph, int unit) {
        for (Node node : graph.getGraph()) {
            for (Edge edge : node.getEdges()) {
                edge.setWeight(unit);
            }
        }
    }
}
```

```java
// BidirectionalState.java
package graph;

public class BidirectionalState implements RouteState {
    @Override
    public void changeDirection(Graph graph, boolean directed) {
        for (Node node : graph.getGraph()) {
            for (Edge edge : node.getEdges()) {
                edge.setDirected(false);
            }
        }
    }

    @Override
    public void changeTimeUnit(Graph graph, int unit) {
        for (Node node : graph.getGraph()) {
            for (Edge edge : node.getEdges()) {
                edge.setWeight(unit);
            }
        }
    }
}
```

حال با استفاده از اینترفیس تعریف‌شه، دو کلاس جدا برای هراستیت تعریف می‌کنم. یکی برای یال‌های یک‌جهته و یکی برای یال‌های دو‌جهته. برای هرکلاس، یک متود changeDirection وجود دارد که جهت یال‌ها را با‌توجه به آن استیت تغییر می‌دهد و یک changeaTimeUnit وجود دارد که برای تغییر دادن واحد زمانی سفر قطار (وزن یال‌ گراف) می‌باشد.

```java
// RouteContext.java
package graph;

public class RouteContext {
    private RouteState state;

    public void setState(RouteState state) {
        this.state = state;
    }

    public void changeDirection(Graph graph, boolean directed) {
        state.changeDirection(graph, directed);
    }

    public void changeUnit(Graph graph, int unit) {
        state.changeTimeUnit(graph, unit);
    }
}
```

در آخر نیز یک کلاس RouteContext درنظر می‌گیرم که یک فیلد آن استیت مورد‌نظر است و با این امکان که میتوان استیت را عوض کرد و متود موردنظر را بدون توجه به نوع استیت بر آن اعمال کرد.

#### الگو strategy
طبق تعریف مساله، برای رفتن از یک شهر به شهر دیگر، دو راه با اتوبوس و یا قطار وجود دارد. با‌توجه به اینکه واحد زمانی برای حرکت اتوبوس ثابت است، در اینجا از الگوریتم bfs برای محاسبه زمان رسیدن به یک شهر با اتوبوس استفاده می‌کنیم و از الگوریتم dijkstra برای محاسبه زمان رسیدن با استفاده از قطار بهره می‌بریم. با‌توجه به اینکه در حین اجرا برنامه، ممکن است ما به هر دوی این روش‌ها برای محاسبه زمان رسیدن نیاز داشته باشیم، این ویژگی همانند استیت در بخش قبلی نیست و درنتیجه اینجا از الگو pattern برای پیاده‌سازی این ویژگی استفاده می‌کنم.

```java
// DistanceStrategy.java
package graph;

public interface DistanceStrategy {
    void calculateDistance(Node start, Node hate);
}
```

در اینجا مشابه بخش قبل یک اینترفیس برای تعریف متود محاسبه فاصله برای هر دو استراتژی ایجاد می‌کنم.
```java
// BfsStrategy.java
package graph;

public class BfsStrategy implements DistanceStrategy {
    private Graph graph;

    public BfsStrategy(Graph graph) {
        this.graph = graph;
    }

    @Override
    public void calculateDistance(Node start, Node hate) {
        graph.bfs(start, hate);
    }
}
```

```java
// DijkstraStrategy.java
package graph;

public class DijkstraStrategy implements DistanceStrategy {
    private Graph graph;

    public DijkstraStrategy(Graph graph) {
        this.graph = graph;
    }

    @Override
    public void calculateDistance(Node start, Node hate) {
        graph.dijkstra(start, hate);
    }
}
```

حال در اینجا برای هر روش یک کلاس ایجاد می‌کنم که متناسب با هر روش متود محاسبه فاصله آن بر آبجکت گراف محاسبه شود. در این صورت، برای پیاده‌سازی برنامه اصلی میتوانیم یک شی از کلاس هر روش داشته باشیم و از هردوی آنها همزمان برای محاسبه فاصله‌ها استفاده کنیم.


### دستورات برنامه اصلی 
در اینجا نحوه کار کردن با برنامه اصلی که در اینجا (در فایل Main.java) نوشته شده است را توضیح می‌دهم. با احرا برنامه، در ابتدا باید تعداد گره‌های گراف را مشخص کنید. بعد از تعیین آن، گره‌های با شماره ۱ تا n که تعداد گره است، ایجاد می‌شوند. بعد از آن باید تعداد یال‌ها را مشخص کنید و بعد،‌ به ازای هر یال شماره گره‌های انتهایی یال‌را مشخص کنید که باید به ازای هر یال، در یک خط شماره یال ابتدایی و انتهایی را با استفاده از شماره آنها تعیین کنید. مثال:

graph sample:

1----2----3----4

input sample:

4

3

1    2

2    3

3    4

بعد از اینکه گراف ایجاد شد، حال با استفاده از دستورات زیر می‌توان این درخواست‌ها را از سیستم داشت:
1. unidirectionalize all routes: یک طرفه کردن همه مسیرها
2. make all routes bidirectional: دو‌طرفه کردن همه مسیر‌ها
3. change train time unit: تغییر دادن واحد زمانی، بعد از وارد کردن این دستور، باید یک عدد ضحیح مثبت به‌عنوان واحد زمانی جدید وارد کنید.
4. distance by train: محاسبه فاصله زمانی با حرکت اتوبوس، بعد از وارد کردن این دستور باید شهر مبدا و مقصد مشخص شوند. مثال:
input example:
distance by train
1 4

5. distance by bus: محاسبه فاصله شهر با حرکت قطار. مشابه دستور قبلی با شهر مبدا و مقصد مشخص شوند.
6. fastest way to travel: با تعیین شهر مبدا و مقصد، میتواند مشخص کند با حرکت اتوبوس سریع‌تر به مقصد می‌رسید یا با قطار
7. possible to avoid city: با تعیین شهر مبدا و مقصد و شماره شهر مورد‌نفرت، نشان می‌دهد که آیا میتوان بدون عبور از شهر مورد‌نفرت به مقصد رسید یا نه. مثال ورودی:
input example:
possible to avoid city
1 2 3 (origin, dest, hated)
8. exit: خروج از برنامه

## پاسخ به سوالات

### 1
در کتاب **GoF (Gang of Four)**، الگوهای طراحی به سه دسته اصلی تقسیم شده‌اند:

1. **الگوهای ساختاری (Creational Patterns)**: این دسته الگوهایی را شامل می‌شود که به نحوه ایجاد اشیاء و نمونه‌ها می‌پردازد و به دنبال این است که فرآیند ایجاد را انعطاف‌پذیرتر و مستقل از سیستم‌ها کند.

2. **الگوهای ساختاری (Structural Patterns)**: این دسته به ترکیب کلاس‌ها و اشیاء در ساختارهای بزرگ‌تر و پیچیده‌تر توجه دارد و به ایجاد رابط‌ها و ساختارهایی که اجزاء مختلف را به هم متصل می‌کنند، کمک می‌کند.

3. **الگوهای رفتاری (Behavioral Patterns)**: این دسته الگوهایی را شامل می‌شود که به نحوه تعامل و مسئولیت‌های بین اشیاء می‌پردازد و به توزیع مسئولیت‌ها و برقراری ارتباطات مؤثر بین اشیاء کمک می‌کند.

### 2
الگوهای طراحی استفاده شده در فاز اول آزمایش، یعنی **Strategy** و **State**، هر دو جزو **الگوهای رفتاری (Behavioral Patterns)** هستند. 

این الگوها بر نحوه تعامل و رفتار اشیاء با یکدیگر تمرکز دارند و به توزیع مسئولیت‌ها و مدیریت تغییرات در رفتار سیستم کمک می‌کنند.

### 3
برای پاسخ دادن به سوالات کاربران در فاز اول، با توجه به اینکه سیستم در هر زمان فقط در یکی از دو حالت یک‌طرفه یا دوطرفه قرار دارد، **الگوی طراحی State** مناسب‌ترین انتخاب است. دلیل انتخاب این الگو این است که سیستم به‌صورت پویا بین دو حالت (یک‌طرفه و دوطرفه) تغییر می‌کند و هر حالت رفتار مشخصی را تعریف می‌کند که باید هنگام دریافت درخواست‌ها از آن استفاده شود.

### علت انتخاب الگوی State:
الگوی State به ما اجازه می‌دهد تا رفتار یک شیء را براساس حالت فعلی آن تغییر دهیم، بدون اینکه نیاز به شرط‌های پیچیده (if-else یا switch-case) در کد داشته باشیم. در این حالت، می‌توانیم هر حالت (یک‌طرفه یا دوطرفه) را به صورت یک کلاس جداگانه پیاده‌سازی کنیم که مسئول رفتارهای خاص آن حالت است. این باعث می‌شود کد تمیزتر، خواناتر و قابل‌توسعه‌تر شود.

### نحوه تحقق الگوی State:

1. **تعریف Interface یا Abstract Class برای State**: ابتدا یک Interface یا Abstract Class تعریف می‌شود که شامل متدهایی است که توسط هر حالت باید پیاده‌سازی شود. این متدها شامل رفتارهای مرتبط با هر حالت می‌شوند، مثلاً بررسی فاصله بین دو شهر.

    ```java
    public interface RouteState {
        int calculateDistance(City from, City to, TransportMode mode);
        boolean isDirectRouteAvailable(City from, City to);
    }
    ```

2. **پیاده‌سازی کلاس‌های Concrete برای هر حالت**: برای هر یک از دو حالت (یک‌طرفه و دوطرفه)، یک کلاس مجزا پیاده‌سازی می‌شود که متدهای مربوطه را به‌صورت خاص برای آن حالت پیاده‌سازی می‌کند.

    ```java
    public class OneWayState implements RouteState {
        @Override
        public int calculateDistance(City from, City to, TransportMode mode) {
            // منطق برای حالت یک‌طرفه
        }

        @Override
        public boolean isDirectRouteAvailable(City from, City to) {
            // منطق برای بررسی امکان وجود مسیر یک‌طرفه
        }
    }

    public class TwoWayState implements RouteState {
        @Override
        public int calculateDistance(City from, City to, TransportMode mode) {
            // منطق برای حالت دوطرفه
        }

        @Override
        public boolean isDirectRouteAvailable(City from, City to) {
            // منطق برای بررسی امکان وجود مسیر دوطرفه
        }
    }
    ```

3. **استفاده از الگوی State در کلاس Context**: کلاس Context شامل یک نمونه از Interface یا Abstract Class مربوط به State است و بسته به حالت فعلی، یکی از حالت‌ها را به آن اختصاص می‌دهد. این کلاس متدهای اصلی را پیاده‌سازی می‌کند که بسته به حالت فعلی، فراخوانی‌های مناسب را به شیء State واگذار می‌کند.

    ```java
    public class RouteContext {
        private RouteState currentState;

        public void setState(RouteState state) {
            this.currentState = state;
        }

        public int calculateDistance(City from, City to, TransportMode mode) {
            return currentState.calculateDistance(from, to, mode);
        }

        public boolean isDirectRouteAvailable(City from, City to) {
            return currentState.isDirectRouteAvailable(from, to);
        }
    }
    ```

4. **تغییر حالت بر اساس درخواست‌های استاندار**: هر زمان که استاندار درخواست تغییر حالت بین یک‌طرفه و دوطرفه را می‌دهد، شیء Context حالت خود را به حالت مناسب تغییر می‌دهد.

    ```java
    RouteContext context = new RouteContext();

    // درخواست برای یک‌طرفه کردن مسیرها
    context.setState(new OneWayState());

    // درخواست برای دوطرفه کردن مسیرها
    context.setState(new TwoWayState());
    ```

### نتیجه:
با استفاده از الگوی State، تغییر رفتار سیستم با تغییر حالت به‌سادگی امکان‌پذیر است، بدون نیاز به پیچیدگی‌های شرطی و تغییرات زیاد در کد. این امر باعث می‌شود کد پایدارتر و توسعه‌پذیرتر باشد.

### 4
الگوی طراحی Singleton در بسیاری از موارد با اصول SOLID تطابق ندارد. در ادامه بررسی تحقق یا عدم تحقق هر یک از اصول SOLID در این الگو:

1. **اصل Single Responsibility (SRP)**: الگوی Singleton این اصل را نقض می‌کند، زیرا کلاس Singleton هم مسئول ایجاد نمونه است و هم مسئول ارائه‌ی دسترسی به این نمونه. این دو وظیفه متفاوت هستند و بهتر است از هم جدا شوند.

2. **اصل Open/Closed (OCP)**: الگوی Singleton معمولاً با این اصل تضاد دارد. Singleton به طور معمول امکان گسترش و تغییر بدون تغییر کد اصلی را محدود می‌کند، زیرا تنها یک نمونه از کلاس وجود دارد که باید تغییرات در آن منعکس شود.

3. **اصل Liskov Substitution (LSP)**: این اصل تا حدودی با Singleton قابل تطابق است. اگرچه این الگو اجازه نمی‌دهد که کلاس به راحتی جایگزین شود، اما این نقض مستقیم LSP نیست. با این حال، مشکلاتی ممکن است در زمان جایگزینی زیرکلاس‌ها پیش بیاید.

4. **اصل Interface Segregation (ISP)**: الگوی Singleton با این اصل تضاد مستقیمی ندارد، اما باید توجه داشت که اگر Singleton مسئولیت‌های زیادی داشته باشد، می‌تواند منجر به نقض این اصل شود.

5. **اصل Dependency Inversion (DIP)**: الگوی Singleton این اصل را نقض می‌کند زیرا معمولاً کلاس‌ها به صورت مستقیم به Singleton وابسته می‌شوند. این به معنای وابستگی به یک کلاس خاص است، نه به یک اینترفیس یا abstraction.

در کل، الگوی Singleton معمولاً با اصول SOLID هماهنگ نیست و ممکن است در پروژه‌های بزرگ و پیچیده مشکلاتی ایجاد کند.

### 5
1. **کد تمیز**: کدی است که به‌راحتی قابل خواندن، درک و نگهداری بوده و به سادگی توسط دیگران توسعه داده می‌شود.

2. **بدهی فنی**: هزینه‌ای است که در نتیجه تصمیمات طراحی و توسعه نامناسب یا عجولانه در آینده برای بازنگری و اصلاح کد پرداخت می‌شود.

3. **بوی بد**: نشانه‌هایی در کد هستند که به وجود مشکلات پنهان، پیچیدگی یا ساختار ضعیف اشاره می‌کنند و معمولاً نیاز به بازآرایی دارند.

### 6
در وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته کلی تقسیم می‌شوند:

1. **بوهای بد در کلاس‌ها (Bloaters)**: به کلاس‌ها یا متدهایی اشاره دارد که بیش از حد بزرگ، پیچیده یا طولانی شده‌اند. این دسته شامل مشکلاتی مانند کلاس‌های چاق (Large Class) و متدهای طولانی (Long Method) است.

2. **بوهای بد در شیوه‌های کدنویسی و ساختارها (Object-Orientation Abusers)**: این دسته به استفاده نادرست یا ناقص از اصول شیءگرایی اشاره دارد، مانند استفاده بیش از حد از ارث‌بری (Refused Bequest) یا ایجاد سلسله‌مراتب عمیق در کلاس‌ها (Alternative Classes with Different Interfaces).

3. **بوهای بد در طراحی‌های نامطلوب (Change Preventers)**: این بوها تغییرات در کد را سخت و پرهزینه می‌کنند، مثل وابستگی زیاد کلاس‌ها به یکدیگر (Shotgun Surgery) یا وابستگی‌های متقابل (Parallel Inheritance Hierarchies).

4. **بوهای بد در ارتباطات بین کلاس‌ها (Dispensables)**: این دسته شامل عناصری از کد است که غیرضروری یا اضافی هستند و باید حذف شوند، مانند کدهای مرده (Dead Code) یا نظرات اضافی (Comments).

5. **بوهای بد در برنامه‌ریزی و زمان‌بندی (Couplers)**: این دسته به وابستگی‌های بیش از حد بین کلاس‌ها یا ماژول‌ها اشاره دارد، مانند وابستگی زیاد به پیاده‌سازی‌های خاص (Feature Envy) یا استفاده از کلاس‌های خارجی در جاهای نامناسب (Inappropriate Intimacy).

### 7
بوی بد **Lazy Class** در دسته‌بندی **"بوهای بد در کلاس‌ها (Dispensables)"** قرار می‌گیرد.

### برطرف‌کردن بوی بد Lazy Class:
برای رفع این بوی بد، بازآرایی‌های زیر پیشنهاد می‌شود:
- **Inline Class**: این بازآرایی به معنای ادغام کلاس Lazy با یک کلاس دیگر است که وظایف مشابهی را انجام می‌دهد.
- **Collapse Hierarchy**: اگر کلاس Lazy عضوی از یک سلسله‌مراتب ارث‌بری باشد و ویژگی‌های خاصی به این کلاس اضافه نشده باشد، می‌توان سلسله‌مراتب را ادغام کرد.

### مواقعی که باید این بو را نادیده گرفت:
این بو را می‌توان نادیده گرفت زمانی که:
- برنامه هنوز در حال توسعه و گسترش است و احتمال دارد در آینده کلاس Lazy وظایف و مسئولیت‌های بیشتری به خود بگیرد.
- طراحی فعلی به نوعی مبتنی بر نیازهای آینده است و ممکن است کلاس Lazy در آینده به یک کلاس کلیدی تبدیل شود.

### 8


### 9
پلاگین **formatter** در Maven وظیفه‌ی قالب‌بندی کدهای منبع جاوا را بر عهده دارد. این پلاگین با استفاده از فرمت‌کننده کد Eclipse، کدهای جاوا را طبق تنظیمات مشخص شده در فایل پیکربندی XML قالب‌بندی می‌کند. این پلاگین سه هدف اصلی دارد:

1. **formatter:format**: قالب‌بندی خودکار کدهای جاوا با استفاده از تنظیمات مشخص شده. همچنین، این هدف می‌تواند با بررسی هش (hash) محتوای فایل‌ها از انجام مجدد قالب‌بندی برای کدهایی که قبلاً قالب‌بندی شده‌اند، جلوگیری کند.

2. **formatter:help**: ارائه اطلاعات کمک و توضیحات درباره نحوه استفاده از پلاگین و پارامترهای آن.

3. **formatter:validate**: بررسی قالب‌بندی کدها در زمان اجرای فرآیندهای CI (Continuous Integration). اگر قالب‌بندی کدها مطابق با استانداردهای تعریف شده نباشد، این هدف باعث شکست فرآیند ساخت پروژه می‌شود.

### چرا این پلاگین می‌تواند کمک کننده باشد؟

این پلاگین به دلایل زیر می‌تواند بسیار کمک‌کننده باشد:
- **افزایش خوانایی و یکنواختی کد**: با استفاده از قالب‌بندی یکنواخت، خوانایی کدها افزایش می‌یابد و تمامی تیم از یک سبک کدنویسی پیروی می‌کنند.
- **کاهش اختلافات در سیستم‌های کنترل نسخه**: با یکنواخت شدن قالب‌بندی، تغییرات کوچک و بی‌معنی (مانند تفاوت در فاصله‌ها یا تورفتگی‌ها) در سیستم‌های کنترل نسخه (مثل Git) کاهش می‌یابد.
- **صرفه‌جویی در زمان**: توسعه‌دهندگان به جای صرف زمان برای رعایت جزئیات قالب‌بندی، می‌توانند تمرکز بیشتری روی منطق و کیفیت کد داشته باشند.

### رابطه‌ی آن با بازآرایی کد:

پلاگین formatter به طور مستقیم بازآرایی (Refactoring) را انجام نمی‌دهد، اما رابطه نزدیکی با آن دارد. بازآرایی کد معمولاً به تغییر ساختار داخلی کد بدون تغییر در رفتار بیرونی آن گفته می‌شود و هدف آن بهبود خوانایی، نگهداری و کارایی کد است. پس از انجام بازآرایی‌ها، استفاده از پلاگین formatter می‌تواند اطمینان حاصل کند که کدهای تغییر یافته به صورت یکنواخت و استاندارد قالب‌بندی شده‌اند، که این امر باعث می‌شود کدهای بازآرایی شده نیز خوانا و تمیز بمانند.
